{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 3000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"DEU RUIM Invalid routeConfig options (POST /login) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"payload\": {\n    \"output\": \"data\",\n    \"parse\": true,\n    \"maxBytes\": 1048576,\n    \"uploads\": \"C:\\\\Users\\\\Avanade\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"response\": {\n    \"emptyStatusCode\": 200,\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"ranges\": true\n  },\n  \"security\": false,\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"username\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 50\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      },\n      \"senha\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 100\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      }\n    }\n  },\n  \"auth\": false,\n  \"tags\": [\n    \"api\"\n  ],\n  \"deion\" \u001b[31m[1]\u001b[0m: \"Deve gerar um token para o usuario\"\n}\n\u001b[31m\n[1] \"deion\" is not allowed\u001b[0m","level":"error"}
{"message":"DEU RUIM Invalid routeConfig options (POST /login) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"payload\": {\n    \"output\": \"data\",\n    \"parse\": true,\n    \"maxBytes\": 1048576,\n    \"uploads\": \"C:\\\\Users\\\\Avanade\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"response\": {\n    \"emptyStatusCode\": 200,\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"ranges\": true\n  },\n  \"security\": false,\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"username\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 50\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      },\n      \"senha\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 100\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      }\n    }\n  },\n  \"auth\": false,\n  \"tags\": [\n    \"api\"\n  ],\n  \"deion\" \u001b[31m[1]\u001b[0m: \"Deve gerar um token para o usuario\"\n}\n\u001b[31m\n[1] \"deion\" is not allowed\u001b[0m","level":"error"}
{"message":"DEU RUIM Invalid routeConfig options (POST /login) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"payload\": {\n    \"output\": \"data\",\n    \"parse\": true,\n    \"maxBytes\": 1048576,\n    \"uploads\": \"C:\\\\Users\\\\Avanade\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"response\": {\n    \"emptyStatusCode\": 200,\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"ranges\": true\n  },\n  \"security\": false,\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"username\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 50\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      },\n      \"senha\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 100\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      }\n    }\n  },\n  \"auth\": false,\n  \"tags\": [\n    \"api\"\n  ],\n  \"deion\" \u001b[31m[1]\u001b[0m: \"Deve gerar um token para o usuario\"\n}\n\u001b[31m\n[1] \"deion\" is not allowed\u001b[0m","level":"error"}
{"message":"DEU RUIM Invalid routeConfig options (POST /login) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"payload\": {\n    \"output\": \"data\",\n    \"parse\": true,\n    \"maxBytes\": 1048576,\n    \"uploads\": \"C:\\\\Users\\\\Avanade\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"response\": {\n    \"emptyStatusCode\": 200,\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"ranges\": true\n  },\n  \"security\": false,\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"username\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 50\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      },\n      \"senha\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 100\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      }\n    }\n  },\n  \"auth\": false,\n  \"tags\": [\n    \"api\"\n  ],\n  \"deion\" \u001b[31m[1]\u001b[0m: \"Deve gerar um token para o usuario\"\n}\n\u001b[31m\n[1] \"deion\" is not allowed\u001b[0m","level":"error"}
{"message":"DEU RUIM Invalid routeConfig options (POST /login) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"payload\": {\n    \"output\": \"data\",\n    \"parse\": true,\n    \"maxBytes\": 1048576,\n    \"uploads\": \"C:\\\\Users\\\\Avanade\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"response\": {\n    \"emptyStatusCode\": 200,\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"ranges\": true\n  },\n  \"security\": false,\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"username\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 50\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      },\n      \"senha\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 100\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      }\n    }\n  },\n  \"auth\": false,\n  \"tags\": [\n    \"api\"\n  ],\n  \"deion\" \u001b[31m[1]\u001b[0m: \"Deve gerar um token para o usuario\"\n}\n\u001b[31m\n[1] \"deion\" is not allowed\u001b[0m","level":"error"}
{"message":"DEU RUIM Invalid routeConfig options (POST /login) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"payload\": {\n    \"output\": \"data\",\n    \"parse\": true,\n    \"maxBytes\": 1048576,\n    \"uploads\": \"C:\\\\Users\\\\Avanade\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"response\": {\n    \"emptyStatusCode\": 200,\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"ranges\": true\n  },\n  \"security\": false,\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"username\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.username._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 50\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      },\n      \"senha\": {\n        \"isJoi\": true,\n        \"_currentJoi\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n          \"_type\": \"any\",\n          \"_settings\": null,\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {},\n          \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n          \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n          \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n          \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n          \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n          \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n          \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n          \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n          \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n          \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n          \"symbol\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.symbol, args);\\n    },\n          \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n          \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n          \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : undefined;\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n          \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n          \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n\\n            throw err;\\n        }\\n    },\n          \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n          \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n          \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n          \"lazy\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, Lazy, args);\\n    },\n          \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n          \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n          \"extensionSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"object\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {},\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"children\": [\n                {\n                  \"key\": \"base\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                        \"name\": \"type\",\n                        \"arg\": {\n                          \"name\": \"Joi object\",\n                          \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                        }\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"name\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"string\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": 0\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"presence\": \"required\"\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {}\n                  }\n                },\n                {\n                  \"key\": \"coerce\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"pre\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 3\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"language\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    },\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                  }\n                },\n                {\n                  \"key\": \"describe\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"object\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [\n                      {\n                        \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                        \"name\": \"arity\",\n                        \"arg\": 1\n                      }\n                    ],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"func\": true\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"children\": null,\n                      \"renames\": [],\n                      \"dependencies\": [],\n                      \"patterns\": []\n                    }\n                  }\n                },\n                {\n                  \"key\": \"rules\",\n                  \"schema\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                    \"_type\": \"array\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {\n                      \"sparse\": false\n                    },\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {\n                      \"items\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"ordereds\": [],\n                      \"inclusions\": [\n                        {\n                          \"isJoi\": true,\n                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                          \"_type\": \"object\",\n                          \"_settings\": null,\n                          \"_valids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_invalids\": {\n                            \"_set\": {},\n                            \"_hasRef\": false\n                          },\n                          \"_tests\": [],\n                          \"_refs\": [],\n                          \"_flags\": {},\n                          \"_description\": null,\n                          \"_unit\": null,\n                          \"_notes\": [],\n                          \"_tags\": [],\n                          \"_examples\": [],\n                          \"_meta\": [],\n                          \"_inner\": {\n                            \"children\": [\n                              {\n                                \"key\": \"name\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"string\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": 0\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"presence\": \"required\"\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {}\n                                }\n                              },\n                              {\n                                \"key\": \"setup\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 1\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"validate\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"object\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [\n                                    {\n                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                      \"name\": \"arity\",\n                                      \"arg\": 4\n                                    }\n                                  ],\n                                  \"_refs\": [],\n                                  \"_flags\": {\n                                    \"func\": true\n                                  },\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"children\": null,\n                                    \"renames\": [],\n                                    \"dependencies\": [],\n                                    \"patterns\": []\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"params\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": [\n                                              {\n                                                \"regex\": {},\n                                                \"rule\": {\n                                                  \"isJoi\": true,\n                                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                                  \"_type\": \"object\",\n                                                  \"_settings\": null,\n                                                  \"_valids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_invalids\": {\n                                                    \"_set\": {},\n                                                    \"_hasRef\": false\n                                                  },\n                                                  \"_tests\": [\n                                                    {\n                                                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                                      \"name\": \"type\",\n                                                      \"arg\": {\n                                                        \"name\": \"Joi object\",\n                                                        \"ctor\": \"[class {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        Cast = Cast || require('../../cast');\\r\\n\\r\\n        this.isJoi = true;\\r\\n        this._type = 'any';\\r\\n        this._settings = null;\\r\\n        this._valids = new internals.Set();\\r\\n        this._invalids = new internals.Set();\\r\\n        this._tests = [];\\r\\n        this._refs = [];\\r\\n        this._flags = {\\r\\n            /*\\r\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\r\\n             allowOnly: false,\\r\\n             allowUnknown: undefined,\\r\\n             default: undefined,\\r\\n             forbidden: false,\\r\\n             encoding: undefined,\\r\\n             insensitive: false,\\r\\n             trim: false,\\r\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\r\\n             case: undefined,                        // upper, lower\\r\\n             empty: undefined,\\r\\n             func: false,\\r\\n             raw: false\\r\\n             */\\r\\n        };\\r\\n\\r\\n        this._description = null;\\r\\n        this._unit = null;\\r\\n        this._notes = [];\\r\\n        this._tags = [];\\r\\n        this._examples = [];\\r\\n        this._meta = [];\\r\\n\\r\\n        this._inner = {};                           // Hash of arrays of immutable objects\\r\\n    }\\r\\n\\r\\n    _init() {\\r\\n\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    get schemaType() {\\r\\n\\r\\n        return this._type;\\r\\n    }\\r\\n\\r\\n    createError(type, context, state, options, flags = this._flags) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, flags);\\r\\n    }\\r\\n\\r\\n    createOverrideError(type, context, state, options, message, template) {\\r\\n\\r\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\r\\n    }\\r\\n\\r\\n    checkOptions(options) {\\r\\n\\r\\n        Schemas = Schemas || require('../../schemas');\\r\\n\\r\\n        const result = Schemas.options.validate(options);\\r\\n\\r\\n        if (result.error) {\\r\\n            throw new Error(result.error.details[0].message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    clone() {\\r\\n\\r\\n        const obj = Object.create(Object.getPrototypeOf(this));\\r\\n\\r\\n        obj.isJoi = true;\\r\\n        obj._currentJoi = this._currentJoi;\\r\\n        obj._type = this._type;\\r\\n        obj._settings = this._settings;\\r\\n        obj._baseType = this._baseType;\\r\\n        obj._valids = this._valids.slice();\\r\\n        obj._invalids = this._invalids.slice();\\r\\n        obj._tests = this._tests.slice();\\r\\n        obj._refs = this._refs.slice();\\r\\n        obj._flags = Hoek.clone(this._flags);\\r\\n\\r\\n        obj._description = this._description;\\r\\n        obj._unit = this._unit;\\r\\n        obj._notes = this._notes.slice();\\r\\n        obj._tags = this._tags.slice();\\r\\n        obj._examples = this._examples.slice();\\r\\n        obj._meta = this._meta.slice();\\r\\n\\r\\n        obj._inner = {};\\r\\n        const inners = Object.keys(this._inner);\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    concat(schema) {\\r\\n\\r\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\r\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\r\\n\\r\\n        let obj = this.clone();\\r\\n\\r\\n        if (this._type === 'any' && schema._type !== 'any') {\\r\\n\\r\\n            // Reset values as if we were \\\"this\\\"\\r\\n            const tmpObj = schema.clone();\\r\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\r\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\r\\n\\r\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\r\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\r\\n            }\\r\\n\\r\\n            obj = tmpObj;\\r\\n        }\\r\\n\\r\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\r\\n        obj._valids.merge(schema._valids, schema._invalids);\\r\\n        obj._invalids.merge(schema._invalids, schema._valids);\\r\\n        obj._tests.push(...schema._tests);\\r\\n        obj._refs.push(...schema._refs);\\r\\n        if (obj._flags.empty && schema._flags.empty) {\\r\\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else if (schema._flags.empty) {\\r\\n            obj._flags.empty = schema._flags.empty;\\r\\n            const flags = Object.assign({}, schema._flags);\\r\\n            delete flags.empty;\\r\\n            Hoek.merge(obj._flags, flags);\\r\\n        }\\r\\n        else {\\r\\n            Hoek.merge(obj._flags, schema._flags);\\r\\n        }\\r\\n\\r\\n        obj._description = schema._description || obj._description;\\r\\n        obj._unit = schema._unit || obj._unit;\\r\\n        obj._notes.push(...schema._notes);\\r\\n        obj._tags.push(...schema._tags);\\r\\n        obj._examples.push(...schema._examples);\\r\\n        obj._meta.push(...schema._meta);\\r\\n\\r\\n        const inners = Object.keys(schema._inner);\\r\\n        const isObject = obj._type === 'object';\\r\\n        for (let i = 0; i < inners.length; ++i) {\\r\\n            const key = inners[i];\\r\\n            const source = schema._inner[key];\\r\\n            if (source) {\\r\\n                const target = obj._inner[key];\\r\\n                if (target) {\\r\\n                    if (isObject && key === 'children') {\\r\\n                        const keys = {};\\r\\n\\r\\n                        for (let j = 0; j < target.length; ++j) {\\r\\n                            keys[target[j].key] = j;\\r\\n                        }\\r\\n\\r\\n                        for (let j = 0; j < source.length; ++j) {\\r\\n                            const sourceKey = source[j].key;\\r\\n                            if (keys[sourceKey] >= 0) {\\r\\n                                target[keys[sourceKey]] = {\\r\\n                                    key: sourceKey,\\r\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\r\\n                                };\\r\\n                            }\\r\\n                            else {\\r\\n                                target.push(source[j]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        obj._inner[key] = obj._inner[key].concat(source);\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    obj._inner[key] = source.slice();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _test(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _testUnique(name, arg, func, options) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tests = obj._tests.filter((test) => test.name !== name);\\r\\n        obj._tests.push({ func, name, arg, options });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    options(options) {\\r\\n\\r\\n        Hoek.assert(!options.context, 'Cannot override context');\\r\\n        this.checkOptions(options);\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._settings = Settings.concat(obj._settings, options);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    strict(isStrict) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        const convert = isStrict === undefined ? false : !isStrict;\\r\\n        obj._settings = Settings.concat(obj._settings, { convert });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    raw(isRaw) {\\r\\n\\r\\n        const value = isRaw === undefined ? true : isRaw;\\r\\n\\r\\n        if (this._flags.raw === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.raw = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    error(err) {\\r\\n\\r\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.error = err;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    allow(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._invalids.remove(value);\\r\\n            obj._valids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    valid(...values) {\\r\\n\\r\\n        const obj = this.allow(...values);\\r\\n        obj._flags.allowOnly = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    invalid(...values) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        values = Hoek.flatten(values);\\r\\n        for (let i = 0; i < values.length; ++i) {\\r\\n            const value = values[i];\\r\\n\\r\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\r\\n            obj._valids.remove(value);\\r\\n            obj._invalids.add(value, obj._refs);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    required() {\\r\\n\\r\\n        if (this._flags.presence === 'required') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'required';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    optional() {\\r\\n\\r\\n        if (this._flags.presence === 'optional') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'optional';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    forbidden() {\\r\\n\\r\\n        if (this._flags.presence === 'forbidden') {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.presence = 'forbidden';\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n\\r\\n    strip() {\\r\\n\\r\\n        if (this._flags.strip) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.strip = true;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n\\r\\n        if (children.length !== 1 || children[0] !== '') {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\r\\n\\r\\n                return root + child;\\r\\n            });\\r\\n\\r\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\r\\n        }\\r\\n\\r\\n        return this[fn](...args);\\r\\n    }\\r\\n\\r\\n    default(value, description) {\\r\\n\\r\\n        if (typeof value === 'function' &&\\r\\n            !Ref.isRef(value)) {\\r\\n\\r\\n            if (!value.description &&\\r\\n                description) {\\r\\n\\r\\n                value.description = description;\\r\\n            }\\r\\n\\r\\n            if (!this._flags.func) {\\r\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.default = value;\\r\\n        Ref.push(obj._refs, value);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    empty(schema) {\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (schema === undefined) {\\r\\n            delete obj._flags.empty;\\r\\n        }\\r\\n        else {\\r\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    when(condition, options) {\\r\\n\\r\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\r\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\r\\n\\r\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\r\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\r\\n\\r\\n        Alternatives = Alternatives || require('../alternatives');\\r\\n\\r\\n        const alternativeOptions = { then, otherwise };\\r\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\r\\n            alternativeOptions.is = options.is;\\r\\n        }\\r\\n\\r\\n        const obj = Alternatives.when(condition, alternativeOptions);\\r\\n        obj._flags.presence = 'ignore';\\r\\n        obj._baseType = this;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    description(desc) {\\r\\n\\r\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._description = desc;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    notes(notes) {\\r\\n\\r\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._notes = obj._notes.concat(notes);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    tags(tags) {\\r\\n\\r\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._tags = obj._tags.concat(tags);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    meta(meta) {\\r\\n\\r\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._meta = obj._meta.concat(meta);\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    example(...examples) {\\r\\n\\r\\n        Hoek.assert(examples.length > 0, 'Missing examples');\\r\\n\\r\\n        const processed = [];\\r\\n        for (let i = 0; i < examples.length; ++i) {\\r\\n            const example = [].concat(examples[i]);\\r\\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\\r\\n\\r\\n            const value = example[0];\\r\\n            let options = example[1];\\r\\n            if (options !== undefined) {\\r\\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\\r\\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\\r\\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\\r\\n            }\\r\\n            else {\\r\\n                options = {};\\r\\n            }\\r\\n\\r\\n            const localState = new State('', [], options.parent || null);\\r\\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\\r\\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\\r\\n\\r\\n            const ex = { value };\\r\\n            if (Object.keys(options).length) {\\r\\n                ex.options = options;\\r\\n            }\\r\\n\\r\\n            processed.push(ex);\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._examples = processed;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    unit(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._unit = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _prepareEmptyValue(value) {\\r\\n\\r\\n        if (typeof value === 'string' && this._flags.trim) {\\r\\n            return value.trim();\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    _validate(value, state, options, reference) {\\r\\n\\r\\n        const originalValue = value;\\r\\n\\r\\n        // Setup state and settings\\r\\n\\r\\n        state = state || new State('', [], null, reference);\\r\\n\\r\\n        if (this._settings) {\\r\\n            const isDefaultOptions = options === internals.defaults;\\r\\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\\r\\n                options = this._settings[Symbols.settingsCache];\\r\\n            }\\r\\n            else {\\r\\n                options = Settings.concat(options, this._settings);\\r\\n                if (isDefaultOptions) {\\r\\n                    this._settings[Symbols.settingsCache] = options;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        let errors = [];\\r\\n\\r\\n        if (this._coerce) {\\r\\n            const coerced = this._coerce(value, state, options);\\r\\n            if (coerced.errors) {\\r\\n                value = coerced.value;\\r\\n                errors = errors.concat(coerced.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\\r\\n            }\\r\\n\\r\\n            value = coerced.value;\\r\\n        }\\r\\n\\r\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\r\\n            value = undefined;\\r\\n        }\\r\\n\\r\\n        // Check presence requirements\\r\\n\\r\\n        const presence = this._flags.presence || options.presence;\\r\\n        if (presence === 'optional') {\\r\\n            if (value === undefined) {\\r\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\r\\n                if (isDeepDefault && this._type === 'object') {\\r\\n                    value = {};\\r\\n                }\\r\\n                else {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (presence === 'required' &&\\r\\n            value === undefined) {\\r\\n\\r\\n            errors.push(this.createError('any.required', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n        else if (presence === 'forbidden') {\\r\\n            if (value === undefined) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n\\r\\n            errors.push(this.createError('any.unknown', null, state, options));\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        // Check allowed and denied values using the original value\\r\\n\\r\\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n        if (match) {\\r\\n            if (options.convert) {\\r\\n                value = match.value;\\r\\n            }\\r\\n\\r\\n            return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n        }\\r\\n\\r\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly ||\\r\\n                value === undefined) {          // No reason to keep validating missing value\\r\\n\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convert value and validate type\\r\\n\\r\\n        if (this._base) {\\r\\n            const base = this._base(value, state, options);\\r\\n            if (base.errors) {\\r\\n                value = base.value;\\r\\n                errors = errors.concat(base.errors);\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\\r\\n            }\\r\\n\\r\\n            if (base.value !== value) {\\r\\n                value = base.value;\\r\\n\\r\\n                // Check allowed and denied values using the converted value\\r\\n\\r\\n                match = this._valids.get(value, state, options, this._flags.insensitive);\\r\\n                if (match) {\\r\\n                    value = match.value;\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n\\r\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\r\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Required values did not match\\r\\n\\r\\n        if (this._flags.allowOnly) {\\r\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\r\\n            if (options.abortEarly) {\\r\\n                return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate tests\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const test = this._tests[i];\\r\\n            const ret = test.func.call(this, value, state, options);\\r\\n            if (ret instanceof Errors.Err) {\\r\\n                errors.push(ret);\\r\\n                if (options.abortEarly) {\\r\\n                    return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                value = ret;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this._finalizeValue(value, originalValue, errors, state, options);\\r\\n    }\\r\\n\\r\\n    _finalizeValue(value, originalValue, errors, state, options) {\\r\\n\\r\\n        let finalValue;\\r\\n\\r\\n        if (value !== undefined) {\\r\\n            finalValue = this._flags.raw ? originalValue : value;\\r\\n        }\\r\\n        else if (options.noDefaults) {\\r\\n            finalValue = value;\\r\\n        }\\r\\n        else if (Ref.isRef(this._flags.default)) {\\r\\n            finalValue = this._flags.default(state.parent, options);\\r\\n        }\\r\\n        else if (typeof this._flags.default === 'function' &&\\r\\n            !(this._flags.func && !this._flags.default.description)) {\\r\\n\\r\\n            let args;\\r\\n\\r\\n            if (state.parent !== null &&\\r\\n                this._flags.default.length > 0) {\\r\\n\\r\\n                args = [Hoek.clone(state.parent), options];\\r\\n            }\\r\\n\\r\\n            const defaultValue = internals._try(this._flags.default, args);\\r\\n            finalValue = defaultValue.value;\\r\\n            if (defaultValue.error) {\\r\\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            finalValue = Hoek.clone(this._flags.default);\\r\\n        }\\r\\n\\r\\n        if (errors.length && typeof this._flags.error === 'function') {\\r\\n            const change = this._flags.error.call(this, errors);\\r\\n\\r\\n            if (typeof change === 'string') {\\r\\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\r\\n            }\\r\\n            else {\\r\\n                errors = [].concat(change)\\r\\n                    .map((err) => {\\r\\n\\r\\n                        return err instanceof Error ?\\r\\n                            err :\\r\\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\r\\n                    });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            value: this._flags.strip ? undefined : finalValue,\\r\\n            finalValue,\\r\\n            errors: errors.length ? errors : null\\r\\n        };\\r\\n    }\\r\\n\\r\\n    _validateWithOptions(value, options, callback) {\\r\\n\\r\\n        if (options) {\\r\\n            this.checkOptions(options);\\r\\n        }\\r\\n\\r\\n        const settings = Settings.concat(internals.defaults, options);\\r\\n        const result = this._validate(value, null, settings);\\r\\n        const errors = Errors.process(result.errors, value);\\r\\n\\r\\n        if (callback) {\\r\\n            return callback(errors, result.value);\\r\\n        }\\r\\n\\r\\n        return {\\r\\n            error: errors,\\r\\n            value: result.value,\\r\\n            then(resolve, reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value).then(resolve);\\r\\n            },\\r\\n            catch(reject) {\\r\\n\\r\\n                if (errors) {\\r\\n                    return Promise.reject(errors).catch(reject);\\r\\n                }\\r\\n\\r\\n                return Promise.resolve(result.value);\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n\\r\\n    validate(value, options, callback) {\\r\\n\\r\\n        if (typeof options === 'function') {\\r\\n            return this._validateWithOptions(value, null, options);\\r\\n        }\\r\\n\\r\\n        return this._validateWithOptions(value, options, callback);\\r\\n    }\\r\\n\\r\\n    describe() {\\r\\n\\r\\n        const description = {\\r\\n            type: this._type\\r\\n        };\\r\\n\\r\\n        const flags = Object.keys(this._flags);\\r\\n        if (flags.length) {\\r\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\r\\n                description.flags = {};\\r\\n                for (let i = 0; i < flags.length; ++i) {\\r\\n                    const flag = flags[i];\\r\\n                    if (flag === 'empty') {\\r\\n                        description.flags[flag] = this._flags[flag].describe();\\r\\n                    }\\r\\n                    else if (flag === 'default') {\\r\\n                        if (Ref.isRef(this._flags[flag])) {\\r\\n                            description.flags[flag] = this._flags[flag].toString();\\r\\n                        }\\r\\n                        else if (typeof this._flags[flag] === 'function') {\\r\\n                            description.flags[flag] = {\\r\\n                                description: this._flags[flag].description,\\r\\n                                function   : this._flags[flag]\\r\\n                            };\\r\\n                        }\\r\\n                        else {\\r\\n                            description.flags[flag] = this._flags[flag];\\r\\n                        }\\r\\n                    }\\r\\n                    else if (flag === 'lazy' || flag === 'label') {\\r\\n                        // We don't want it in the description\\r\\n                    }\\r\\n                    else {\\r\\n                        description.flags[flag] = this._flags[flag];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                description.flags = this._flags;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._settings) {\\r\\n            description.options = Hoek.clone(this._settings);\\r\\n        }\\r\\n\\r\\n        if (this._baseType) {\\r\\n            description.base = this._baseType.describe();\\r\\n        }\\r\\n\\r\\n        if (this._description) {\\r\\n            description.description = this._description;\\r\\n        }\\r\\n\\r\\n        if (this._notes.length) {\\r\\n            description.notes = this._notes;\\r\\n        }\\r\\n\\r\\n        if (this._tags.length) {\\r\\n            description.tags = this._tags;\\r\\n        }\\r\\n\\r\\n        if (this._meta.length) {\\r\\n            description.meta = this._meta;\\r\\n        }\\r\\n\\r\\n        if (this._examples.length) {\\r\\n            description.examples = this._examples;\\r\\n        }\\r\\n\\r\\n        if (this._unit) {\\r\\n            description.unit = this._unit;\\r\\n        }\\r\\n\\r\\n        const valids = this._valids.values();\\r\\n        if (valids.length) {\\r\\n            description.valids = valids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        const invalids = this._invalids.values();\\r\\n        if (invalids.length) {\\r\\n            description.invalids = invalids.map((v) => {\\r\\n\\r\\n                return Ref.isRef(v) ? v.toString() : v;\\r\\n            });\\r\\n        }\\r\\n\\r\\n        description.rules = [];\\r\\n\\r\\n        for (let i = 0; i < this._tests.length; ++i) {\\r\\n            const validator = this._tests[i];\\r\\n            const item = { name: validator.name };\\r\\n\\r\\n            if (validator.arg !== void 0) {\\r\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\r\\n            }\\r\\n\\r\\n            const options = validator.options;\\r\\n            if (options) {\\r\\n                if (options.hasRef) {\\r\\n                    item.arg = {};\\r\\n                    const keys = Object.keys(validator.arg);\\r\\n                    for (let j = 0; j < keys.length; ++j) {\\r\\n                        const key = keys[j];\\r\\n                        const value = validator.arg[key];\\r\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (typeof options.description === 'string') {\\r\\n                    item.description = options.description;\\r\\n                }\\r\\n                else if (typeof options.description === 'function') {\\r\\n                    item.description = options.description(item.arg);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            description.rules.push(item);\\r\\n        }\\r\\n\\r\\n        if (!description.rules.length) {\\r\\n            delete description.rules;\\r\\n        }\\r\\n\\r\\n        const label = this._getLabel();\\r\\n        if (label) {\\r\\n            description.label = label;\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    label(name) {\\r\\n\\r\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.label = name;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _getLabel(def) {\\r\\n\\r\\n        return this._flags.label || def;\\r\\n    }\\r\\n\\r\\n}]\"\n                                                      }\n                                                    }\n                                                  ],\n                                                  \"_refs\": [],\n                                                  \"_flags\": {},\n                                                  \"_description\": null,\n                                                  \"_unit\": null,\n                                                  \"_notes\": [],\n                                                  \"_tags\": [],\n                                                  \"_examples\": [],\n                                                  \"_meta\": [],\n                                                  \"_inner\": {\n                                                    \"children\": null,\n                                                    \"renames\": [],\n                                                    \"dependencies\": [],\n                                                    \"patterns\": []\n                                                  }\n                                                }\n                                              }\n                                            ]\n                                          }\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        },\n                                              \"name\": \"type\",\n                                              \"arg\": {\n                                                \"name\": \"Joi object\",\n                                                \"ctor\": \"[class extends Any {\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        super();\\r\\n        this._type = 'object';\\r\\n        this._inner.children = null;\\r\\n        this._inner.renames = [];\\r\\n        this._inner.dependencies = [];\\r\\n        this._inner.patterns = [];\\r\\n    }\\r\\n\\r\\n    _init(...args) {\\r\\n\\r\\n        return args.length ? this.keys(...args) : this;\\r\\n    }\\r\\n\\r\\n    _base(value, state, options) {\\r\\n\\r\\n        let target = value;\\r\\n        const errors = [];\\r\\n        const finish = () => {\\r\\n\\r\\n            return {\\r\\n                value: target,\\r\\n                errors: errors.length ? errors : null\\r\\n            };\\r\\n        };\\r\\n\\r\\n        if (typeof value === 'string' &&\\r\\n            options.convert) {\\r\\n\\r\\n            value = internals.safeParse(value);\\r\\n        }\\r\\n\\r\\n        const type = this._flags.func ? 'function' : 'object';\\r\\n        if (!value ||\\r\\n            typeof value !== type ||\\r\\n            Array.isArray(value)) {\\r\\n\\r\\n            errors.push(this.createError(type + '.base', { value }, state, options));\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Skip if there are no other rules to test\\r\\n\\r\\n        if (!this._inner.renames.length &&\\r\\n            !this._inner.dependencies.length &&\\r\\n            !this._inner.children &&                    // null allows any keys\\r\\n            !this._inner.patterns.length) {\\r\\n\\r\\n            target = value;\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        // Ensure target is a local copy (parsed) or shallow copy\\r\\n\\r\\n        if (target === value) {\\r\\n            if (type === 'object') {\\r\\n                target = Object.create(Object.getPrototypeOf(value));\\r\\n            }\\r\\n            else {\\r\\n                target = function (...args) {\\r\\n\\r\\n                    return value.apply(this, args);\\r\\n                };\\r\\n\\r\\n                target.prototype = Hoek.clone(value.prototype);\\r\\n            }\\r\\n\\r\\n            const valueKeys = Object.keys(value);\\r\\n            for (let i = 0; i < valueKeys.length; ++i) {\\r\\n                target[valueKeys[i]] = value[valueKeys[i]];\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            target = value;\\r\\n        }\\r\\n\\r\\n        // Rename keys\\r\\n\\r\\n        const renamed = {};\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            const rename = this._inner.renames[i];\\r\\n\\r\\n            if (rename.isRegExp) {\\r\\n                const targetKeys = Object.keys(target);\\r\\n                const matchedTargetKeys = [];\\r\\n\\r\\n                for (let j = 0; j < targetKeys.length; ++j) {\\r\\n                    if (rename.from.test(targetKeys[j])) {\\r\\n                        matchedTargetKeys.push(targetKeys[j]);\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\r\\n                if (rename.options.ignoreUndefined && allUndefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (allUndefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\r\\n                        delete target[matchedTargetKeys[j]];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                if (!rename.options.multiple &&\\r\\n                    renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\r\\n                    !rename.options.override &&\\r\\n                    !renamed[rename.to]) {\\r\\n\\r\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (target[rename.from] === undefined) {\\r\\n                    delete target[rename.to];\\r\\n                }\\r\\n                else {\\r\\n                    target[rename.to] = target[rename.from];\\r\\n                }\\r\\n\\r\\n                renamed[rename.to] = true;\\r\\n\\r\\n                if (!rename.options.alias) {\\r\\n                    delete target[rename.from];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate schema\\r\\n\\r\\n        if (!this._inner.children &&            // null allows any keys\\r\\n            !this._inner.patterns.length &&\\r\\n            !this._inner.dependencies.length) {\\r\\n\\r\\n            return finish();\\r\\n        }\\r\\n\\r\\n        const unprocessed = new Set(Object.keys(target));\\r\\n\\r\\n        if (this._inner.children) {\\r\\n            const stripProps = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                const key = child.key;\\r\\n                const item = target[key];\\r\\n\\r\\n                unprocessed.delete(key);\\r\\n\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const result = child.schema._validate(item, localState, options);\\r\\n                if (result.errors) {\\r\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\r\\n\\r\\n                    if (options.abortEarly) {\\r\\n                        return finish();\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\r\\n                        stripProps.push(key);\\r\\n                        target[key] = result.finalValue;\\r\\n                    }\\r\\n                    else if (result.value !== undefined) {\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for (let i = 0; i < stripProps.length; ++i) {\\r\\n                delete target[stripProps[i]];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Unknown keys\\r\\n\\r\\n        if (unprocessed.size && this._inner.patterns.length) {\\r\\n\\r\\n            for (const key of unprocessed) {\\r\\n                const localState = new State(key, [...state.path, key], target, state.reference);\\r\\n                const item = target[key];\\r\\n\\r\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                    const pattern = this._inner.patterns[i];\\r\\n\\r\\n                    if (pattern.regex ?\\r\\n                        pattern.regex.test(key) :\\r\\n                        !pattern.schema.validate(key).error) {\\r\\n\\r\\n                        unprocessed.delete(key);\\r\\n\\r\\n                        const result = pattern.rule._validate(item, localState, options);\\r\\n                        if (result.errors) {\\r\\n                            errors.push(this.createError('object.child', {\\r\\n                                key,\\r\\n                                child: pattern.rule._getLabel(key),\\r\\n                                reason: result.errors\\r\\n                            }, localState, options));\\r\\n\\r\\n                            if (options.abortEarly) {\\r\\n                                return finish();\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        target[key] = result.value;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\r\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\r\\n                options.skipFunctions) {\\r\\n\\r\\n                const stripUnknown = options.stripUnknown\\r\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\r\\n                    : false;\\r\\n\\r\\n\\r\\n                for (const key of unprocessed) {\\r\\n                    if (stripUnknown) {\\r\\n                        delete target[key];\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                    else if (typeof target[key] === 'function') {\\r\\n                        unprocessed.delete(key);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\r\\n\\r\\n                for (const unprocessedKey of unprocessed) {\\r\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\\r\\n                        key: unprocessedKey,\\r\\n                        path: [...state.path, unprocessedKey]\\r\\n                    }, options, {}));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Validate dependencies\\r\\n\\r\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\r\\n            const dep = this._inner.dependencies[i];\\r\\n            const hasKey = dep.key !== null;\\r\\n            const splitKey = hasKey && dep.key.split('.');\\r\\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\\r\\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key), dep.peers, target, localState, options);\\r\\n            if (err instanceof Errors.Err) {\\r\\n                errors.push(err);\\r\\n                if (options.abortEarly) {\\r\\n                    return finish();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return finish();\\r\\n    }\\r\\n\\r\\n    keys(schema) {\\r\\n\\r\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\r\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        if (!schema) {\\r\\n            obj._inner.children = null;\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const children = Object.keys(schema);\\r\\n\\r\\n        if (!children.length) {\\r\\n            obj._inner.children = [];\\r\\n            return obj;\\r\\n        }\\r\\n\\r\\n        const topo = new Topo();\\r\\n        if (obj._inner.children) {\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n\\r\\n                // Only add the key if we are not going to replace it later\\r\\n                if (!children.includes(child.key)) {\\r\\n                    topo.add(child, { after: child._refs, group: child.key });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (let i = 0; i < children.length; ++i) {\\r\\n            const key = children[i];\\r\\n            const child = schema[key];\\r\\n            try {\\r\\n                const cast = Cast.schema(this._currentJoi, child);\\r\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\r\\n            }\\r\\n            catch (castErr) {\\r\\n                if (castErr.hasOwnProperty('path')) {\\r\\n                    castErr.path = key + '.' + castErr.path;\\r\\n                }\\r\\n                else {\\r\\n                    castErr.path = key;\\r\\n                }\\r\\n\\r\\n                throw castErr;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        obj._inner.children = topo.nodes;\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    append(schema) {\\r\\n        // Skip any changes\\r\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        return this.keys(schema);\\r\\n    }\\r\\n\\r\\n    unknown(allow) {\\r\\n\\r\\n        const value = allow !== false;\\r\\n\\r\\n        if (this._flags.allowUnknown === value) {\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._flags.allowUnknown = value;\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    length(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('length', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length === limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.length', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    min(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('min', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length >= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.min', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    max(limit) {\\r\\n\\r\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\r\\n\\r\\n        return this._test('max', limit, function (value, state, options) {\\r\\n\\r\\n            if (Object.keys(value).length <= limit) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.max', { limit, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    pattern(pattern, schema) {\\r\\n\\r\\n        const isRegExp = pattern instanceof RegExp;\\r\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\r\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\r\\n\\r\\n        if (isRegExp) {\\r\\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        if (isRegExp) {\\r\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\r\\n        }\\r\\n        else {\\r\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\r\\n        }\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    schema() {\\r\\n\\r\\n        return this._test('schema', null, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof Any) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.schema', null, state, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    with(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('with', key, peers);\\r\\n    }\\r\\n\\r\\n    without(key, peers) {\\r\\n\\r\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\r\\n\\r\\n        return this._dependency('without', key, peers);\\r\\n    }\\r\\n\\r\\n    xor(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('xor', null, peers);\\r\\n    }\\r\\n\\r\\n    or(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('or', null, peers);\\r\\n    }\\r\\n\\r\\n    and(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('and', null, peers);\\r\\n    }\\r\\n\\r\\n    nand(...peers) {\\r\\n\\r\\n        peers = Hoek.flatten(peers);\\r\\n        return this._dependency('nand', null, peers);\\r\\n    }\\r\\n\\r\\n    requiredKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'required');\\r\\n    }\\r\\n\\r\\n    optionalKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'optional');\\r\\n    }\\r\\n\\r\\n    forbiddenKeys(...children) {\\r\\n\\r\\n        children = Hoek.flatten(children);\\r\\n        return this.applyFunctionToChildren(children, 'forbidden');\\r\\n    }\\r\\n\\r\\n    rename(from, to, options) {\\r\\n\\r\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\r\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\r\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\r\\n\\r\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\r\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n\\r\\n        obj._inner.renames.push({\\r\\n            from,\\r\\n            to,\\r\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\r\\n            isRegExp: from instanceof RegExp\\r\\n        });\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    applyFunctionToChildren(children, fn, args = [], root) {\\r\\n\\r\\n        children = [].concat(children);\\r\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\r\\n\\r\\n        const groupedChildren = internals.groupChildren(children);\\r\\n        let obj;\\r\\n\\r\\n        if ('' in groupedChildren) {\\r\\n            obj = this[fn](...args);\\r\\n            delete groupedChildren[''];\\r\\n        }\\r\\n        else {\\r\\n            obj = this.clone();\\r\\n        }\\r\\n\\r\\n        if (obj._inner.children) {\\r\\n            root = root ? (root + '.') : '';\\r\\n\\r\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\r\\n                const child = obj._inner.children[i];\\r\\n                const group = groupedChildren[child.key];\\r\\n\\r\\n                if (group) {\\r\\n                    obj._inner.children[i] = {\\r\\n                        key: child.key,\\r\\n                        _refs: child._refs,\\r\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\r\\n                    };\\r\\n\\r\\n                    delete groupedChildren[child.key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        const remaining = Object.keys(groupedChildren);\\r\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\r\\n\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    _dependency(type, key, peers) {\\r\\n\\r\\n        peers = [].concat(peers);\\r\\n        for (let i = 0; i < peers.length; ++i) {\\r\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\r\\n        }\\r\\n\\r\\n        const obj = this.clone();\\r\\n        obj._inner.dependencies.push({ type, key, peers });\\r\\n        return obj;\\r\\n    }\\r\\n\\r\\n    describe(shallow) {\\r\\n\\r\\n        const description = super.describe();\\r\\n\\r\\n        if (description.rules) {\\r\\n            for (let i = 0; i < description.rules.length; ++i) {\\r\\n                const rule = description.rules[i];\\r\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\r\\n                if (/* $lab:coverage:off$ */rule.arg &&\\r\\n                    typeof rule.arg === 'object' &&\\r\\n                    rule.arg.schema &&\\r\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\r\\n                    rule.arg = {\\r\\n                        schema: rule.arg.schema.describe(),\\r\\n                        ref: rule.arg.ref.toString()\\r\\n                    };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.children &&\\r\\n            !shallow) {\\r\\n\\r\\n            description.children = {};\\r\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\r\\n                const child = this._inner.children[i];\\r\\n                description.children[child.key] = child.schema.describe();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.dependencies.length) {\\r\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\r\\n        }\\r\\n\\r\\n        if (this._inner.patterns.length) {\\r\\n            description.patterns = [];\\r\\n\\r\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\r\\n                const pattern = this._inner.patterns[i];\\r\\n                if (pattern.regex) {\\r\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n                else {\\r\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (this._inner.renames.length > 0) {\\r\\n            description.renames = Hoek.clone(this._inner.renames);\\r\\n        }\\r\\n\\r\\n        return description;\\r\\n    }\\r\\n\\r\\n    assert(ref, schema, message) {\\r\\n\\r\\n        ref = Cast.ref(ref);\\r\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\r\\n        message = message || 'pass the assertion test';\\r\\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\\r\\n\\r\\n        try {\\r\\n            schema = Cast.schema(this._currentJoi, schema);\\r\\n        }\\r\\n        catch (castErr) {\\r\\n            if (castErr.hasOwnProperty('path')) {\\r\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\r\\n            }\\r\\n\\r\\n            throw castErr;\\r\\n        }\\r\\n\\r\\n        const key = ref.path[ref.path.length - 1];\\r\\n        const path = ref.path.join('.');\\r\\n\\r\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\r\\n\\r\\n            const result = schema._validate(ref(value), null, options, value);\\r\\n            if (!result.errors) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            const localState = new State(key, ref.path, state.parent, state.reference);\\r\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    type(constructor, name = constructor.name) {\\r\\n\\r\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\r\\n        const typeData = {\\r\\n            name,\\r\\n            ctor: constructor\\r\\n        };\\r\\n\\r\\n        return this._test('type', typeData, function (value, state, options) {\\r\\n\\r\\n            if (value instanceof constructor) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\\r\\n        });\\r\\n    }\\r\\n}]\"\n                                              }\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              },\n                              {\n                                \"key\": \"description\",\n                                \"schema\": {\n                                  \"isJoi\": true,\n                                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                  \"_type\": \"alternatives\",\n                                  \"_settings\": null,\n                                  \"_valids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_invalids\": {\n                                    \"_set\": {},\n                                    \"_hasRef\": false\n                                  },\n                                  \"_tests\": [],\n                                  \"_refs\": [],\n                                  \"_flags\": {},\n                                  \"_description\": null,\n                                  \"_unit\": null,\n                                  \"_notes\": [],\n                                  \"_tags\": [],\n                                  \"_examples\": [],\n                                  \"_meta\": [],\n                                  \"_inner\": {\n                                    \"matches\": [\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_type\": \"string\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": 0\n                                          },\n                                          \"_tests\": [],\n                                          \"_refs\": [],\n                                          \"_flags\": {},\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {},\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                                        }\n                                      },\n                                      {\n                                        \"schema\": {\n                                          \"isJoi\": true,\n                                          \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                                          \"_type\": \"object\",\n                                          \"_settings\": null,\n                                          \"_valids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_invalids\": {\n                                            \"_set\": {},\n                                            \"_hasRef\": false\n                                          },\n                                          \"_tests\": [\n                                            {\n                                              \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                                              \"name\": \"arity\",\n                                              \"arg\": 1\n                                            }\n                                          ],\n                                          \"_refs\": [],\n                                          \"_flags\": {\n                                            \"func\": true\n                                          },\n                                          \"_description\": null,\n                                          \"_unit\": null,\n                                          \"_notes\": [],\n                                          \"_tags\": [],\n                                          \"_examples\": [],\n                                          \"_meta\": [],\n                                          \"_inner\": {\n                                            \"children\": null,\n                                            \"renames\": [],\n                                            \"dependencies\": [],\n                                            \"patterns\": []\n                                          }\n                                        }\n                                      }\n                                    ]\n                                  }\n                                }\n                              }\n                            ],\n                            \"renames\": [],\n                            \"dependencies\": [\n                              {\n                                \"type\": \"or\",\n                                \"key\": null,\n                                \"peers\": [\n                                  \"setup\",\n                                  \"validate\"\n                                ]\n                              }\n                            ],\n                            \"patterns\": []\n                          }\n                        }\n                      ],\n                      \"exclusions\": [],\n                      \"requireds\": []\n                    }\n                  }\n                }\n              ],\n              \"renames\": [],\n              \"dependencies\": [],\n              \"patterns\": []\n            }\n          },\n          \"extensionsSchema\": {\n            \"isJoi\": true,\n            \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n            \"_type\": \"array\",\n            \"_settings\": {\n              \"convert\": false\n            },\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  },\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\"\n                },\n                {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.validate.payload.senha._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\r\\n\\r\\n            if (value.length === n) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('function.arity', { n }, state, options);\\r\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          },\n          \"version\": \"14.0.4\"\n        },\n        \"_type\": \"string\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": 0\n        },\n        \"_tests\": [\n          {\n            \"func\": function (value, state, options) {\\r\\n\\r\\n            let compareTo;\\r\\n            if (isRef) {\\r\\n                compareTo = limit(state.reference || state.parent, options);\\r\\n\\r\\n                if (!Number.isSafeInteger(compareTo)) {\\r\\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                compareTo = limit;\\r\\n            }\\r\\n\\r\\n            if (compare(value, compareTo, encoding)) {\\r\\n                return value;\\r\\n            }\\r\\n\\r\\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\\r\\n        },\n            \"name\": \"max\",\n            \"arg\": 100\n          }\n        ],\n        \"_refs\": [],\n        \"_flags\": {\n          \"presence\": \"required\"\n        },\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {}\n      }\n    }\n  },\n  \"auth\": false,\n  \"tags\": [\n    \"api\"\n  ],\n  \"descriptionn\" \u001b[31m[1]\u001b[0m: \"Deve gerar um token para o usuario\"\n}\n\u001b[31m\n[1] \"descriptionn\" is not allowed\u001b[0m","level":"error"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"servidor rodando, 4000","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
{"message":"Servidor rodando em: 4000 ","level":"info"}
